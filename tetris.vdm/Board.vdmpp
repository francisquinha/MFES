class Board

	types
	
		public Position = seq of int
		inv position == len position = 2;
		public Matrix = map Position to nat;


	instance variables
	
		public static maxRow		: nat1			:= 22;
		public static maxVisibleRow	: nat1			:= 20;
		public static maxColumn		: nat1			:= 10;

		private print_startTag		: Game`String	:= "▕";
		private print_endTag		: Game`String	:= "▏\n";
		private print_bottomLine	: Game`String	:= " ▔▔▔▔▔▔▔▔▔▔";
		                                        
		private matrix 				: Matrix		:= {|->};
     
                                               							
	operations
	
		------------------------------------------------------------ Board
		public Board : () ==> Board
		Board() == (	
			self.initBoard();
		);
		
		------------------------------------------------------------ initBoard
		public initBoard : () ==> ()
		initBoard() == (		
			for i = 1 to maxRow do
				for j = 1 to maxColumn do
					matrix := matrix ++ {[i,j] |-> 0}
		)
		post matrix([1,1]) = 0 and matrix([maxRow, maxColumn]) = 0;

		------------------------------------------------------------ printBoard
		public getBoardPrint : bool * bool * bool ==> Game`String
		getBoardPrint(printNow, blackConsole, testPrint) == (	

			dcl print_board	: Game`String := "\n";
			dcl start_row : nat1 := 3;
			
			if testPrint then start_row := 1;
								
			for i = start_row to maxRow do(
				print_board := print_board ^ print_startTag;
	  			for j=1 to maxColumn do
	  				print_board := print_board 
	  					^ getCellPrint(matrix([i,j]), i, blackConsole);
	  			print_board := print_board ^  print_endTag;
	  		);
	  		
	  		if printNow then
	  			IO`println(print_board ^ print_bottomLine);
	  		
	 		return print_board ^ print_bottomLine ;	  							  							
		);
		
		private getCellPrint: nat * nat * bool ==> Game`String
		getCellPrint(id, row, blackConsole) == (
			if blackConsole then
				cases id:
					0 -> if row < 3 then return " " else return "░",
					others -> return "█"
				end
			else
				cases id:
					0 -> if row < 3 then return " " else return "░",
					1 -> return "\u001B[38;5;51m" ^ "█" ^ "\u001B[0m",
					2 -> return "\u001B[38;5;21m" ^ "█" ^ "\u001B[0m",
					3 -> return "\u001B[38;5;208m" ^ "█" ^ "\u001B[0m",
					4 -> return "\u001B[38;5;226m" ^ "█" ^ "\u001B[0m",
					5 -> return "\u001B[38;5;34m" ^ "█" ^ "\u001B[0m",
					6 -> return "\u001B[38;5;165m" ^ "█" ^ "\u001B[0m",
					others -> return "\u001B[38;5;196m" ^ "█" ^ "\u001B[0m"				
				end
		);
		
		------------------------------------------------------------ checkRow
		public checkRow : int ==> bool
		checkRow(row) == (
			for column = 1 to maxColumn do
				if (matrix([row, column]) = 0) then return false;
			for i = row - 1 to 1 by -1 do
				for j = 1 to maxColumn do
					matrix([i + 1, j]) := matrix([i, j]);
			return true
		)
		pre row >= 1 and row <= maxRow;
		
		public checkRows : () ==> nat
		checkRows() == (
			dcl result : nat := 0;
			for row = 1 to maxRow do
				if checkRow(row) then result := result + 1;
			return result
		)
		post RESULT <= maxRow;
		
		public setMatrixPosition : Position * nat ==> ()
		setMatrixPosition(position, value) ==
			matrix(position) := value
		pre position(1) >= 1
			and position(1) <= maxRow 
			and position(2) >= 1
			and position(2) <= maxColumn;	
		
		public getMatrixPosition : Position ==> nat
		getMatrixPosition(position) ==
			return matrix(position)		
		pre position(1) >= 1
			and position(1) <= maxRow 
			and position(2) >= 1
			and position(2) <= maxColumn;	
	
			
end Board