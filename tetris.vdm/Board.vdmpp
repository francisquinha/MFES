class Board

	types
		public String = seq of char;
		public Position = seq of nat
		inv position == len position = 2;
		public Matrix = map Position to nat;

	instance variables
		private print_startTag		: String	:= "▕";
		private print_endTag		: String	:= "▏\n";
		private print_bottomLine	: String	:= " ▔▔▔▔▔▔▔▔▔▔▔";
		private print_emptyCell		: String	:= "░";
	  	private print_filledCell	: String	:= "█";
		                                        
		private maxRow				: nat		:= 22;
		private maxVisibleRow		: nat		:= 20;
		private maxColumn			: nat		:= 10;
		                                        
		private matrix 				: Matrix	:= {|->};
                                                
		private gameOver			: bool		:= false;
		
							
	operations
		------------------------------------------------------------ Board
		public Board : () ==> Board
		Board() == (	
			self.initBoard();
		);
		
		------------------------------------------------------------ initBoard
		public initBoard : () ==> ()
		initBoard() == (		
			for i = 1 to maxRow do
				for j = 1 to maxColumn do
					matrix := matrix ++ {[i,j] |-> 0}
		);
		--post len row1 =12;
		--pre len matrix <=0

		------------------------------------------------------------ printBoard
		public getBoardPrint : (String) ==> String
		getBoardPrint(option) == (	

			dcl print_board	: String := "\n";
								
			for i = 1 to maxRow do(
				print_board := print_board ^ print_startTag;
	  			for j=1 to maxColumn do (
	  				if (matrix([i,j]) > 0) then
	  					print_board := print_board ^ print_filledCell
	  				
	  				else if (i< 3) then
	  					print_board := print_board ^ " "
	  				else
	  					print_board := print_board ^ print_emptyCell;
	  			);
	  			print_board := print_board ^  print_endTag;
	  		);
	  		
	  		if (option = "printBoard") then
	  			IO`println(print_board ^ print_bottomLine);
	  		
	 		return print_board ^ print_bottomLine ;	  							  							
		);
		
		------------------------------------------------------------ get matrix board
		public  getBoard : (String)  ==> Matrix
		getBoard(option) ==(
			
			if (option = "printMatrix" ) then
	  			IO`println(self.matrix);
		
			return self.matrix;
		);
		
		------------------------------------------------------------ checkRow
		public checkRow : int ==> bool
		checkRow(row) == (
			for column = 1 to maxColumn do
				if (matrix([row, column]) = 0) then return false;
			for i = row - 1 to 1 by -1 do
				for j = 1 to maxColumn do
					matrix([i + 1, j]) := matrix([i, j]);
			return true
		);
		
		public checkRows : () ==> nat
		checkRows() == (
			dcl result : nat := 0;
			for row = 1 to maxRow do
				if checkRow(row) then result := result + 1;
			return result
		); 
			
		public setMatrixPosition : Position * nat ==> ()
		setMatrixPosition(position, value) ==
			matrix(position) := value;	
		
		public getMatrixPosition : Position ==> nat
		getMatrixPosition(position) ==
			return matrix(position);	
				
		public setGameOver : () ==> ()
		setGameOver() ==
			gameOver := true;
			
		public getGameOver : () ==> bool
		getGameOver() ==
			return gameOver;
			
		public getMaxRow : () ==> nat
		getMaxRow() ==
			return maxRow;

		public getMaxVisibleRow : () ==> nat
		getMaxVisibleRow() ==
			return maxVisibleRow;

		public getMaxColumn : () ==> nat
		getMaxColumn() ==
			return maxColumn;
			
		public addTetramino : () ==> Tetramino
		addTetramino() == (		
			dcl tetramino : Tetramino;
			dcl random : nat1 := MATH`rand(7) + 1;
			cases random:
				1 -> tetramino := new TetraminoI(self),
				2 -> tetramino := new TetraminoJ(self),
				3 -> tetramino := new TetraminoL(self),
				4 -> tetramino := new TetraminoO(self),
				5 -> tetramino := new TetraminoS(self),
				6 -> tetramino := new TetraminoT(self),
				7 -> tetramino := new TetraminoZ(self)
			end;
			return tetramino;
		);

end Board