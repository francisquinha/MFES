class Tetramino

	types 
	
		public Color = <Cyan> | <Blue> | <Orange> 
			| <Yellow> | <Green> | <Purple> | <Red>;
		public Minoes = seq of Board`Position
		inv minoes == len minoes = 4


	instance variables
	
		private color				: Color  	:= <Cyan>;
		private id					: nat 	 	:= 0;
		private orientation			: nat 	 	:= 0;
		private minoes				: Minoes	:= [[1, 1], [1, 2], [1, 3], [1, 4]];
	
		inv id <= 7 and orientation < 4
		
	
	functions
	
		private checkPosition : Board`Position * int * int * int * int -> bool
		checkPosition(position, min1, max1, min2, max2) == 
			position(1) >= min1
			and position(1) <= max1 
			and position(2) >= min2
			and position(2) <= max2;
			
		private checkMinoes: Minoes * int * int * int * int -> bool
		checkMinoes(minoes, min1, max1, min2, max2) ==
			card elems minoes = 4 
			and forall mino in set elems minoes & 
				checkPosition(mino, min1, max1, min2, max2)
	
	
	operations
		
		public setColor : Color ==> ()
		setColor(c) == color := c;
		
		public setId : nat ==> ()
		setId(i) == id := i
		pre i >= 1 and i <= 7;
		
		public getOrientation : () ==> nat
		getOrientation() == return orientation
		post RESULT < 4;
		
		public getMinoes : () ==> Minoes
		getMinoes() == return minoes;

		public setMinoes : Board * Board`Position ==> bool
		setMinoes(board, position) == (
			dcl tempMinoes : Minoes := minoes;
			dcl tempPosition : Board`Position := position;
			removeTetramino(board);
			for i = 1 to 4 do (
				if (validPosition(board, tempPosition)) 
				then tempMinoes(i) := tempPosition
				else (
					addTetramino(board);
					return false
				);
				tempPosition := getNextMino(tempPosition, i);
			);				
			minoes := tempMinoes;
			addTetramino(board);
			return true
		)
		pre checkPosition(position, -1, Board`maxRow + 2, -1, Board`maxColumn + 2)
		post checkMinoes(minoes, 1, Board`maxRow, 1, Board`maxColumn);
		
		public initialSetMinoes : Game * Board`Position ==> ()
		initialSetMinoes(game, position) == (
			dcl tempPosition : Board`Position := position;
			dcl tempMinoes : Minoes := minoes;
			for i = 1 to 4 do (
				if (validPosition(game.getBoard(), tempPosition)) 
				then (
					tempMinoes(i) := tempPosition;
					tempPosition := getNextMino(tempPosition, i)
				)	
				else game.setGameOver()
			);			
			if not game.getGameOver() then (
				minoes := tempMinoes;
				addTetramino(game.getBoard())
			)
		)
		pre checkPosition(position, 1, Board`maxRow, 1, Board`maxColumn)
		post checkMinoes(minoes, 1, Board`maxRow, 1, Board`maxColumn);
		
		public getNextMino: Board`Position * nat ==> Board`Position
		getNextMino(position, index) ==
			is subclass responsibility
		pre index in set {1, ..., 4} 
			and checkPosition(position, 1, Board`maxRow, 1, Board`maxColumn)
		post checkPosition(RESULT, 0, Board`maxRow + 1, 0, Board`maxColumn + 1);
			
		public getRotatedMino: Board`Position ==> Board`Position
		getRotatedMino(position) ==
			is subclass responsibility
		pre checkPosition(position, 1, Board`maxRow, 1, Board`maxColumn)
		post checkPosition(RESULT, -1, Board`maxRow + 2, -1, Board`maxColumn + 2); 

		public validPosition : Board * Board`Position ==> bool
		validPosition(board, position) == 
			return checkPosition(position, 1, Board`maxRow, 1, Board`maxColumn) 
				and board.getMatrixPosition(position) = 0;

		public removeTetramino : Board ==> ()
		removeTetramino(board) ==
			for mino in minoes do
				board.setMatrixPosition(mino, 0)
		pre checkMinoes(minoes, 1, Board`maxRow, 1, Board`maxColumn);

		public addTetramino : Board ==> ()
		addTetramino(board) ==
			for mino in minoes do
				board.setMatrixPosition(mino, id)
		pre checkMinoes(minoes, 1, Board`maxRow, 1, Board`maxColumn);

		public moveDown : Board ==> bool
		moveDown(board) == 
			return setMinoes(board, [minoes(1)(1) + 1, minoes(1)(2)])
		pre checkMinoes(minoes, 1, Board`maxRow, 1, Board`maxColumn)
		post checkMinoes(minoes, 1, Board`maxRow, 1, Board`maxColumn);
					
		public moveLeft : Board ==> bool
		moveLeft(board) == 
			return setMinoes(board, [minoes(1)(1), minoes(1)(2) - 1])
		pre checkMinoes(minoes, 1, Board`maxRow, 1, Board`maxColumn)
		post checkMinoes(minoes, 1, Board`maxRow, 1, Board`maxColumn);
		
		public moveRight : Board ==> bool
		moveRight(board) == 
			return setMinoes(board, [minoes(1)(1), minoes(1)(2) + 1])
		pre checkMinoes(minoes, 1, Board`maxRow, 1, Board`maxColumn)
		post checkMinoes(minoes, 1, Board`maxRow, 1, Board`maxColumn);

		public rotate : Board ==> bool
		rotate(board) == (
			dcl position : Board`Position := getRotatedMino(minoes(1));
			orientation := (orientation + 1) mod 4;
			return setMinoes(board, position)
		)
		pre checkMinoes(minoes, 1, Board`maxRow, 1, Board`maxColumn)
		post checkMinoes(minoes, 1, Board`maxRow, 1, Board`maxColumn);
		
		public drop : Board ==> nat
		drop(board) == (
			dcl result : nat := 0;
			while moveDown(board) do 
				result := result + 1;
			return result
		)
		pre checkMinoes(minoes, 1, Board`maxRow, 1, Board`maxColumn)
		post checkMinoes(minoes, 1, Board`maxRow, 1, Board`maxColumn) and RESULT < Board`maxRow;
		
end Tetramino
