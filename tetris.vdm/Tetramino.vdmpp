class Tetramino

	types 
		public Color = <Cyan> | <Blue> | <Orange> | <Yellow> | <Green> | <Purple> | <Red>;
		public Minoes = seq1 of Board`Position
		inv minoes == len minoes = 4 and card elems minoes = 4

	instance variables
		private color: Color := <Cyan>;
		private id: nat := 0;
		private orientation: nat := 0;
		private minoes: Minoes := [[0, 0], [0, 1], [0, 2], [0, 3]]
	
	operations
	
		public Tetramino : (Board) ==> Tetramino
		Tetramino(board) ==
			is subclass responsibility;
		
		public setColor : Color ==> ()
		setColor(c) == color := c;
		
		public setId : nat ==> ()
		setId(i) == id := i;
		
		public getOrientation : () ==> nat
		getOrientation() == return orientation;

		public setOrientation : nat ==> ()
		setOrientation(o) == orientation := o;

		public setMinoes : Board * Board`Position ==> bool
		setMinoes(board, position) == (
			dcl tempMinoes : Minoes := minoes;
			dcl tempPosition : Board`Position := position;
			removeTetramino(board);
			for i = 0 to 3 do (
				if (validPosition(board, tempPosition)) 
				then tempMinoes(i) := tempPosition
				else (
					addTetramino(board);
					return false
				);
				tempPosition := getNextMino(tempPosition, i);
			);				
			minoes := tempMinoes;
			addTetramino(board);
			return true
		);
		
		public initialSetMinoes : Board * Board`Position ==> ()
		initialSetMinoes(board, position) == (
			dcl tempPosition : Board`Position := position;
			for i = 0 to 3 do (
				if (validPosition(board, tempPosition)) 
				then minoes(i) := tempPosition
				else (
					board.setGameOver();
					return
				);
				tempPosition := getNextMino(tempPosition, i);
			);				
			addTetramino(board);
			return
		);
		
		public getNextMino: Board`Position * nat ==> Board`Position
		getNextMino(position, index) ==
			is subclass responsibility;
			
		public getRotatedMino: Board`Position ==> Board`Position
		getRotatedMino(position) ==
			is subclass responsibility;

		public validPosition : Board * Board`Position ==> bool
		validPosition(board, position) ==
			if position(0) < 0 then return false
			else if position(0) >= board.getTotalRows() then return false
			else if position(1) < 0 then return false
			else if position(1) >= board.getTotalColumns() then return false
			else if board.getMatrixPosition(position) <> 0 then return false
			else return true;
			
		public removeTetramino : Board ==> ()
		removeTetramino(board) ==
			for mino in minoes do
				board.setMatrixPosition(mino, 0);

		public addTetramino : Board ==> ()
		addTetramino(board) ==
			for mino in minoes do
				board.setMatrixPosition(mino, id);

		public moveDown : Board ==> bool
		moveDown(board) == 
			return setMinoes(board, [minoes(0)(0) - 1, minoes(0)(1)]);
					
		public moveLeft : Board ==> bool
		moveLeft(board) == 
			return setMinoes(board, [minoes(0)(0), minoes(0)(1) - 1]);
		
		public moveRight : Board ==> bool
		moveRight(board) == 
			return setMinoes(board, [minoes(0)(0), minoes(0)(1) + 1]);

		public rotate : Board ==> bool
		rotate(board) == (
			dcl position : Board`Position := getRotatedMino(minoes(0));
			orientation := (orientation + 1) mod 4;
			return setMinoes(board, position)
		);
		
		public drop : Board ==> nat
		drop(board) == (
			dcl result : nat := 0;
			while moveDown(board) do 
				result := result + 1;
			return result
		);
		
end Tetramino
