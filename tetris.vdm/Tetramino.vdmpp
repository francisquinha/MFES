class Tetramino

	types 
		public Color = <Cyan> | <Blue> | <Orange> | <Yellow> | <Green> | <Purple> | <Red>;
		public Minoes = seq of Board`Position
		inv minoes == len minoes = 4 --and card elems minoes = 4

	instance variables
		private color: Color := <Cyan>;
		private id: nat := 0;
		private orientation: nat := 0;
		private minoes: Minoes := [[1, 1], [1, 2], [1, 3], [1, 4]]
	
	operations
		
		public setColor : Color ==> ()
		setColor(c) == color := c;
		
		public setId : nat ==> ()
		setId(i) == id := i;
		
		public getOrientation : () ==> nat
		getOrientation() == return orientation;

--		public setOrientation : nat ==> ()
--		setOrientation(o) == orientation := o;

		public setMinoes : Board * Board`Position ==> bool
		setMinoes(board, position) == (
			dcl tempMinoes : Minoes := minoes;
			dcl tempPosition : Board`Position := position;
			removeTetramino(board);
			for i = 1 to 4 do (
				if (validPosition(board, tempPosition)) 
				then tempMinoes(i) := tempPosition
				else (
					addTetramino(board);
					return false
				);
				tempPosition := getNextMino(tempPosition, i);
			);				
			minoes := tempMinoes;
			addTetramino(board);
			return true
		);
		
		public initialSetMinoes : Board * Board`Position ==> ()
		initialSetMinoes(board, position) == (
			dcl tempPosition : Board`Position := position;
			for i = 1 to 4 do (
				if (validPosition(board, tempPosition)) 
				then (
					minoes(i) := tempPosition;
					tempPosition := getNextMino(tempPosition, i)
				)	
				else board.setGameOver()
			);			
			if not board.getGameOver() then addTetramino(board);
		);
		
		public getNextMino: Board`Position * nat ==> Board`Position
		getNextMino(position, index) ==
			is subclass responsibility;
			
		public getRotatedMino: Board`Position ==> Board`Position
		getRotatedMino(position) ==
			is subclass responsibility;

		public validPosition : Board * Board`Position ==> bool
		validPosition(board, position) ==
			if position(1) < 1 then return false
			else if position(1) > board.getMaxRow() then return false
			else if position(2) < 1 then return false
			else if position(2) > board.getMaxColumn() then return false
			else if board.getMatrixPosition(position) <> 0 then return false
			else return true;
			
		public removeTetramino : Board ==> ()
		removeTetramino(board) ==
			for mino in minoes do
				board.setMatrixPosition(mino, 0);

		public addTetramino : Board ==> ()
		addTetramino(board) ==
			for mino in minoes do
				board.setMatrixPosition(mino, id);

		public moveDown : Board ==> bool
		moveDown(board) == 
			return setMinoes(board, [minoes(1)(1) + 1, minoes(1)(2)]);
					
		public moveLeft : Board ==> bool
		moveLeft(board) == 
			return setMinoes(board, [minoes(1)(1), minoes(1)(2) - 1]);
		
		public moveRight : Board ==> bool
		moveRight(board) == 
			return setMinoes(board, [minoes(1)(1), minoes(1)(2) + 1]);

		public rotate : Board ==> bool
		rotate(board) == (
			dcl position : Board`Position := getRotatedMino(minoes(1));
			orientation := (orientation + 1) mod 4;
			return setMinoes(board, position)
		);
		
		public drop : Board ==> nat
		drop(board) == (
			dcl result : nat := 0;
			while moveDown(board) do 
				result := result + 1;
			return result
		);
		
end Tetramino
